# 4. Рекурсия, указатели, структуры
## Рекурсия
С вызовом других функций мы уже сталкивались, а что будет, если вызвать функцию внутри её самой?<br>
**Рекурсивная функция** - это функция, в записи которой содержится она сама.
Пример рекурсивной функции в математике (функция возвращает `n`-ное число Фибоначчи):<br>
$F(0) = 0$<br>
$F(1) = 1$<br>
$F(n) = F(n - 1) + F(n - 2)$<br>
Такую же функцию можно построить и в программировании:
```golang
func fib(n int) int {
	if n == 0 || n == 1 {
		return n
	}
	return fib(n - 1) + fib(n - 2)
}
```
При вызове этой рекурсивной функции каждый раз будет вызываться еще парочка, полный ход выполнения можно проследить на картинке:
![fibonacci](https://github.com/papashik/elena/assets/96551531/d5985c71-98ef-4ee6-8faf-e782d6ea9acb)
Компилятору абсолютно все равно, где находится вызываемая функция, 
как мы помним, функции - это просто инструкции процессора, размещенные в оперативной памяти последовательно.
И от того, что находится в специальном регистре - счетчике команд (_IP - Instruction Pointer_) - зависит то,
какая инструкция будет выполняться следующей. Поэтому технически рекурсивный вызов функции ничем не отличается от обычного.
### Ещё пример - рекурсивное возведение числа в степень
```golang
func power(a float64, e int) float64 {
	if e == 0 {
		return 1 // завершение рекурсии
	} else if e < 0 {
		return 1 / power(a, -e) // расчет отрицательных степеней
	}
	return a * power(a, e - 1) // основная рекурсия
}
```
