# Golang - основы 5. Структуры
Предположим, мы пишем социальную сеть на Go.<br>
Нам понадобится много функций для обработки данных пользователей - для регистрации, добавления друзей,
отправки сообщений и файлов, замены фотографии профиля и так далее.
Для подобных действий функциям нужны данные пользователя - им нужно знать, кому и куда что добавить,
что поменять, от чьего имени отправить сообщение и т.д.<br> 
Так как хранить данные пользователей в глобальных переменных неразумно (почему?), сигнатуры наших функций будут увеличиваться
со скоростью света, обрастая разными подробностями о пользователе. 
К примеру, функция, каким-то образом обрабатывающая данные пользователя, должна знать: его уникальный идентификатор, имя, фамилию,
страну, город, дату рождения, фотографию его профиля, количество друзей, количество подписчиков, онлайн ли он сейчас,
когда последний раз был онлайн и еще много-много информации 
(пример - какие данные есть у [пользователя ВК](https://dev.vk.com/ru/reference/objects/user)):
```golang
// Наша функция могла бы выглядеть так:
func DoSomething(user_id, friends_count, followers_count int, name, surname, country, city string, birth_date, was_online date, is_online bool, profile_photo photo) {
    ...
}
```
Такие функции плохи тем, что работать с ними тяжело, нужно помнить порядок передаваемых параметров, в каких функциях есть
дополнительные аргументы, а в каких нет, да и уж больно их объявление длинное - даже не помещается в строчку на GitHub. Что же делать?
## Структуры
**Структура** - это составной тип данных, значение которого представляет собой последовательность именованных полей разных типов.<br>
Давайте заведем отдельную переменную под целого пользователя, которая будет хранить все его данные - своеобразный "ящик"
с другими переменными (переменные, хранящиеся внутри структуры, называются **полями структуры**). 
И тогда в функции, работающие с данными пользователя, можно будет передавать только одну переменную!

```golang
// Объявления полей в простейшем случае аналогичны объявлениям переменных, но не начинаются с ключевого слова var.
struct {
    имена_полей тип_полей
    имена_полей тип_полей
    ...
}
```
### Пример - использование безымянной структуры
```golang
package main
import "fmt"

func main() {
    var my_user struct { // объявление переменной типа `структура`
                    name, surname string
                    id int
                }
    my_user.name = "Alexander" // обращение к полям структуры для записи
    my_user.surname = "Kudimov"
    my_user.id = 1
    fmt.Printf("User: %s %s\nId: %d", my_user.name, my_user.surname, my_user.id) // обращение к полям структуры для чтения
    // выведет:
    // `User: Alexander Kudimov`
    // `Id: 1`
}
```
## Именованные структуры
Чтобы дать структуре имя, нужно объявить пользовательский именованный тип 
(об этом мы будем говорить подробнее, а пока просто запомните синтаксис).
### Пример - структура с именем
```golang
package main
import "fmt"

type User struct { // объявление пользовательского типа структуры
    name, surname string
    id, friends_count int
}

func main() {
    var pavel User // создание структуры, в этот момент все поля инициализирутся нулевыми значениями
    pavel.name = "Pavel"
    pavel.surname = "Yakubov"
    pavel.id = 31415
    PrintUser(pavel)
}

func PrintUser(user User) { // принимает один параметр типа "User"
    fmt.Printf("User: %s %s, Id: %d, Friends: %d\n", user.name, user.surname, user.id, user.friends_count)
    // выведет `User: Pavel Yakubov, Id: 31415, Friends: 0` - при создании структуры поля инициализируются нулевыми значениями
}
```
## Структурные литералы
**Литерал** – это изображение некоторого значения (целого числа, числа с плавающей точкой, строки и т.п.) в исходном тексте программы.
Примеры литералов: `57` (числовой литерал), `"pavel"` (строковой литерал), `false` (булевый литерал), 
`0,43` (литерал с плавающей точкой), `[]int{1, 2, 3}` (массивовый литерал) и т.д. <br>
Для структур тоже существуют составные литералы, похожие на массивовые литералы.
Они записываются так:
```golang
тип_структуры { значения_полей }
```
или так
```golang
тип_структуры { поле: значение, ..., поле: значение }
```
### Пример - несколько структур и структурные литералы
```golang
package main
import "fmt"

type Moment struct { // структурный тип, обозначающий момент времени
    year, month, day, hour, minute, second, millisecond int
}

type Message struct { // структурный тип, обозначающий сообщение (например, в социальной сети)
    from_id, to_id int           // от кого и кому
    text string                  // текст сообщения
    time Moment                  // время отправки
}

// функция отправляет сообщение (в нашем случае - в консоль)
func SendMessage(mes Message) {
    fmt.Println(mes)
}

func main() {
    var mes1 Message
    mes1.from_id = 123
    mes1.to_id = 456
    mes1.text = "Привет!"
    mes1.time = Moment{2023, 10, 4, 9, 0, 0, 0}
    SendMessage(mes1) // выведет `{123 456 Привет! {2023 10 4 9 0 0 0}}`

    // при использовании литерала с именами полей необязательно заполнять их все
    // (остальные заполнятся нулевыми значениями):
    time2 := Moment{year: 2023, month: 10, day: 5, hour: 10} // minute = 0, second = 0, millisecond = 0
    mes2 := Message{from_id: 456, to_id: 123, text: "И тебе привет!", time: time2}
    SendMessage(mes2) // выведет `{456 123 И тебе привет! {2023 10 5 10 0 0 0}}`


    // структурный литерал можно использовать даже с безымянной структурой:
    my_point := struct{ x, y int } {15, 35}
    fmt.Printf("X = %d, Y = %d\n", my_point.x, my_point.y) // выведет `X = 15, Y = 35`
}
```
## Структурные методы
И последний важный момент - 



